# 프론트엔드 엔지니어 (React / Next.js) 인터뷰 답변 — 2026 에디션

아래 답변은 "면접에서 바로 말할 수 있는 길이"를 목표로 했습니다. 실제 연습에서는 본인 프로젝트 사례를 1–2개씩 붙이세요.

## 1. React 핵심 멘탈 모델
1. **React 컴포넌트는 무엇이 트리거되어 리렌더링되나요?**  
컴포넌트의 state가 바뀌거나, 부모가 새 props로 다시 렌더링되거나, 소비 중인 context 값이 바뀌거나, 외부 스토어 구독이 업데이트를 알릴 때 리렌더링됩니다. React 18+에서는 업데이트가 기본적으로 배칭되지만, 영향받는 컴포넌트에 대해 새로운 렌더 패스는 여전히 발생합니다. 리렌더링은 "UI를 다시 계산"하는 과정이지, 곧바로 DOM을 바꾸는 과정은 아닙니다.
2. **리렌더링과 DOM 업데이트의 차이는 무엇인가요?**  
리렌더링은 컴포넌트 함수를 다시 실행해 새로운 가상 트리를 만드는 단계입니다. 실제 DOM 변경은 그 다음 커밋 단계에서, 비교(reconciliation) 결과 "정말 바뀐 부분"에만 적용됩니다. 그래서 출력이 안정적이면 렌더가 여러 번 일어나도 생각보다 비용이 작을 수 있습니다.
3. **React의 reconciliation 알고리즘을 높은 수준에서 설명해 주세요.**  
React는 이전 트리와 다음 트리를 비교하면서 type과 key를 기준으로 노드를 매칭합니다. type이나 key가 바뀌면 해당 서브트리를 새 것으로 보고 재마운트할 수 있습니다. 목표는 가능한 많이 재사용해서 DOM 작업을 최소화하고, identity가 안정적일 때 state를 보존하는 것입니다.
4. **리스트에서 key가 왜 중요한가요? index를 key로 쓰면 어떤 문제가 생기나요?**  
key는 항목의 "안정적인 정체성(identity)"을 React에 알려줍니다. index를 key로 쓰면 삽입/삭제/정렬 시 identity가 밀려서 state가 엉뚱한 항목으로 이동하거나, 불필요한 재마운트/DOM churn이 발생합니다. 가능하면 데이터의 고유 ID를 key로 쓰는 것이 안전합니다.
5. **stale closure는 어떤 문제를 만들까요?**  
콜백이나 effect가 과거의 props/state 값을 캡처한 채로 나중에도 그 값을 계속 쓰는 문제가 생깁니다. 특히 타이머, 구독, async 흐름에서 "어제는 됐는데 오늘은 안 되는" 류의 버그를 만듭니다. 보통은 의존성 배열을 바로잡거나, functional update를 쓰거나, 최신 값을 ref에서 읽는 방식으로 해결합니다.
6. **functional state update는 언제 쓰나요?**  
다음 state가 이전 state에 의존할 때 사용합니다. 예를 들어 카운터, 큐, 토글 같은 경우 `setX(prev => ...)`가 안전합니다. stale closure를 줄이고, 안정적인 콜백/동시성 모델과도 궁합이 좋습니다.
7. **props로부터 state를 직접 파생시키면 왜 안 좋은가요?**  
"진실의 원천(source of truth)"이 두 개가 되면서 쉽게 불일치가 납니다. 대부분은 렌더 중 계산하거나, 비싸다면 메모이제이션으로 해결하는 편이 낫습니다. 정말 로컬 복사가 필요하면 "언제 어떻게 동기화할지" 규칙을 명시해야 합니다.
8. **controlled vs uncontrolled 컴포넌트의 차이는 무엇인가요?**  
controlled는 값의 원천이 React state이고, 이벤트로 state를 갱신해 예측 가능성과 검증이 쉽습니다. uncontrolled는 값의 원천이 DOM이고 ref나 `defaultValue`로 다룹니다. 큰 앱에서는 일관성과 테스트 용이성 때문에 controlled를 더 자주 선택합니다.
9. **컴포넌트가 "pure"하다는 것은 무슨 뜻인가요?**  
같은 props/state/context가 들어오면 같은 UI를 반환하고, 렌더 중에는 부수효과(side effect)를 만들지 않는다는 뜻입니다. 순수성은 추론을 쉽게 만들고, 메모이제이션 같은 최적화에도 유리합니다. 부수효과는 이벤트 핸들러, effect, 서버 액션 같은 곳에 둬야 합니다.
10. **컴포넌트 트리가 깊게 중첩되면 어떤 문제가 생기나요?**  
prop drilling, state 소유권 불명확, 먼 곳의 변화로 인한 과한 리렌더링이 생기기 쉽습니다. 보통 관심사 분리가 약하고 경계(boundary)가 부족하다는 신호입니다. 해결책으로는 feature 단위 구조화, 선택적 context, 서버 컴포넌트 활용, state를 쓰는 곳 가까이에 두기가 있습니다.

## 2. Hooks 깊은 이해
1. **언제 useMemo를 쓰지 말아야 하나요?**  
값 계산이 싼데도 습관적으로 `useMemo`를 쓰는 것은 피해야 합니다. 오히려 복잡도와 오버헤드를 늘릴 수 있습니다. 측정해서 병목이 확인됐거나, 참조 안정성이 "정확성/성능에 실제로 필요"할 때만 쓰는 것이 좋습니다.
2. **useCallback은 언제 실제로 도움이 되나요?**  
안정적인 함수 참조가 자식 컴포넌트의 불필요한 리렌더를 막을 때(특히 자식이 `memo`일 때) 효과가 큽니다. 또한 effect 의존성을 안정화할 때 유용할 수 있습니다. 그 외에는 코드 소음만 늘리는 경우가 많습니다.
3. **hooks를 잘못 쓰면 성능에 어떤 악영향이 있나요?**  
과한 메모이제이션, 불안정한 의존성, effect가 불필요한 추가 렌더를 유발하는 패턴이 대표적입니다. 렌더가 잦은 컴포넌트 안에서 비싼 일을 수행하는 것도 흔한 실수입니다. 최적화는 "측정 → 원인 파악 → 국소적 수정" 순서가 안전합니다.
4. **useEffect에서 무한 렌더 루프가 생기는 원인은 무엇인가요?**  
effect가 state를 바꾸고, 그 state 변화가 의존성을 다시 바꿔 effect를 재실행시키는 고리가 생길 때 발생합니다. 렌더마다 새로 만들어지는 객체/함수를 의존성에 넣는 것도 흔한 원인입니다. 의존성 바로잡기, functional update, 불안정한 참조를 분리하는 방식으로 끊습니다.
5. **의존성 배열은 실제로 어떻게 동작하나요?**  
React는 렌더 이후 각 의존성을 "참조 동일성(shallow reference)"으로 비교합니다. 이전 렌더와 다른 값이 하나라도 있으면 effect/memo/callback이 다시 실행됩니다. 그래서 원시값 의존성, 안정적인 참조가 예측 가능한 동작을 만듭니다.
6. **useEffect 안의 async 작업은 어떻게 취소하나요?**  
`fetch`라면 `AbortController`를 쓰고, cleanup에서 abort합니다. 또는 cleanup에서 `cancelled` 플래그를 세우고 늦게 도착한 응답을 무시합니다. 서버 state는 TanStack Query 같은 라이브러리를 쓰면 이 문제가 많이 줄어듭니다.
7. **useRef와 state의 차이는 무엇인가요?**  
state는 렌더 결과의 일부이며 바뀌면 리렌더링을 트리거합니다. ref는 렌더 사이에 유지되는 가변 상자지만, 값을 바꿔도 리렌더링을 일으키지 않습니다. DOM 노드, 인스턴스성 값, 최신 값을 콜백에서 읽는 용도에 적합합니다.
8. **useEffect 대신 useLayoutEffect를 써야 하는 경우는 언제인가요?**  
브라우저가 페인트하기 전에 레이아웃을 읽거나 DOM을 동기적으로 수정해야 할 때입니다(측정, 위치 계산, 깜빡임 방지 등). `useLayoutEffect`는 페인트를 막을 수 있어 비용이 크므로, 정말 필요한 경우에만 써야 합니다. 대부분의 부수효과는 `useEffect`가 더 안전합니다.
9. **custom hook은 아키텍처에 어떤 이점을 주나요?**  
상태 로직과 부수효과를 "의도가 분명한 API"로 묶어 재사용성과 가독성을 높입니다. 컴포넌트를 렌더 중심으로 유지하고, 로직은 hook으로 이동시켜 관심사를 분리할 수 있습니다. 좋은 custom hook은 `useDebouncedValue`, `useUserProfile`처럼 이름만으로 역할이 드러납니다.
10. **동작이 들쑥날쑥한 hook은 어떻게 디버깅하나요?**  
의존성, stale closure, cleanup 타이밍부터 점검합니다. 개발 모드의 Strict Mode는 일부 라이프사이클을 의도적으로 두 번 실행하므로 숨겨진 부수효과를 드러낼 수 있습니다. 작은 재현 케이스로 격리하고, 키/의존성/identity 가정을 하나씩 확인하는 방식이 가장 빠릅니다.

## 3. React 18+ & 동시성 기능
1. **concurrent rendering은 어떤 문제를 해결하나요?**  
렌더링을 "중단 가능"하고 "우선순위화"할 수 있게 만들어, 무거운 렌더 중에도 입력 반응성을 유지하도록 돕습니다. 모든 것을 병렬로 만드는 개념은 아니고, 스케줄링 제어권을 React가 더 많이 갖는 것입니다. 결과적으로 "렌더 때문에 UI가 멈춘 느낌"을 줄입니다.
2. **startTransition은 무엇에 쓰나요?**  
비긴급(non-urgent) 업데이트임을 React에 알려 우선순위를 낮추는 데 씁니다. 큰 리스트 필터링, 라우트 전환, 탭 전환처럼 렌더 비용이 큰 작업에 특히 효과적입니다. 요지는 "지금 당장 입력 반응성이 더 중요하다"는 신호입니다.
3. **데이터 페칭에서 Suspense는 어떤 의미가 있나요?**  
로딩 경계를 선언적으로 표현하고, 경계 단위로 준비된 UI부터 보여줄 수 있게 합니다. 특히 서버 렌더링/스트리밍과 결합할 때 효과가 큽니다. 좋은 경계는 의미 있는 UI 덩어리(섹션) 단위로 두는 것입니다.
4. **streaming rendering이란 무엇인가요?**  
서버가 모든 준비가 끝날 때까지 기다리지 않고, 준비된 HTML부터 조각 단위로 내려보내는 렌더링 방식입니다. TTFB와 체감 속도에 유리합니다. Suspense 경계가 스트리밍 단위를 자연스럽게 만들어 줍니다.
5. **selective hydration이란 무엇인가요?**  
페이지 전체를 한 번에 하이드레이션하는 대신, 더 중요한/인터랙티브한 부분부터 우선 하이드레이션하는 전략입니다. 큰 페이지나 느린 기기에서 반응성을 개선합니다. 동시성 모델의 스케줄링 이점을 활용하는 사례입니다.
6. **어떤 UI가 transitions의 이점을 크게 보나요?**  
검색/필터, 탭 전환, 라우트 전환처럼 "입력은 즉시 반응"하고 "결과는 조금 늦어도 되는" UI가 대표적입니다. 사용자는 결과 지연보다 입력 지연을 더 불쾌하게 느끼는 경우가 많습니다. 그래서 transitions는 체감 품질을 개선하는 도구로 설명하면 좋습니다.
7. **Suspense 경계를 과하게 쓰면 어떤 문제가 있나요?**  
로딩이 잘게 쪼개져 시각적으로 불안정한 pop-in이 생길 수 있습니다. 에러/로딩 상태 관리가 복잡해지고 경계 간 상호작용도 어려워집니다. 보통은 "논리적 섹션 단위"로 경계를 두고 fallback을 의도적으로 설계하는 편이 낫습니다.
8. **urgent 업데이트와 non-urgent 업데이트의 차이는 무엇인가요?**  
urgent는 타이핑, 클릭, 포커스처럼 즉시 반응해야 하는 업데이트입니다. non-urgent는 결과 표시, 무거운 파생 UI처럼 잠깐 늦어도 UX가 괜찮은 업데이트입니다. 이 구분을 코드에 표현하는 도구가 transition입니다.
9. **React는 어떻게 메인 스레드를 덜 막게 만드나요?**  
렌더링 작업을 작은 단위로 나누고, 중간에 브라우저에 제어권을 넘길 수 있도록 스케줄링합니다. 그래서 입력 처리나 페인트가 렌더에 장시간 묶이지 않도록 돕습니다. 개발자가 모든 걸 바꾸기보다는, React가 더 똑똑하게 일을 나누는 느낌으로 설명하면 정확합니다.
10. **동시성은 어떤 UI 문제에 특히 잘 맞나요?**  
무거운 렌더 때문에 입력이 느려지는 문제, 라우트/탭 전환의 끊김, 로딩 상태 조율이 어려운 문제에 강합니다. 큰 서브트리가 자주 갱신되는 화면에서 특히 체감 차이가 납니다. 핵심 목표는 "부하가 걸려도 반응성 유지"입니다.

## 4. Next.js (2026 현실)
1. **Server Component와 Client Component의 차이는 무엇인가요?**  
Server Component는 서버에서 실행되고, DB/시크릿에 직접 접근 가능하며, 그 컴포넌트 코드는 브라우저로 보내지지 않습니다. Client Component는 브라우저에서 실행되고 state/effect/이벤트 핸들러를 쓸 수 있지만, 그만큼 JS 번들에 포함됩니다. 실전에서는 "가능한 한 서버, 필요한 인터랙션만 클라이언트"가 기본 전략입니다.
2. **언제 Client Component여야 하나요?**  
`useState`, `useEffect` 같은 클라이언트 훅을 쓰거나, `window` 같은 브라우저 API를 쓰거나, `onClick` 같은 이벤트 핸들러가 필요할 때입니다. 브라우저 인터랙션이 필요하지 않다면 서버 컴포넌트를 우선 고려하는 것이 번들 크기 측면에서 유리합니다.
3. **hydration이 무엇이고, mismatch는 왜 생기나요?**  
hydration은 서버가 만든 HTML에 React를 붙여 인터랙티브하게 만드는 과정입니다. mismatch는 서버와 클라이언트의 초기 렌더 결과가 다를 때 생깁니다(시간/랜덤 값, 브라우저 전용 분기, 사용자별 데이터 차이 등). 해결은 렌더 결과를 결정적으로 만들거나, 클라이언트 전용 차이를 hydration 이후로 미루는 것입니다.
4. **App Router와 Pages Router의 차이는 무엇인가요?**  
App Router는 중첩 레이아웃, 서버 컴포넌트, Suspense/스트리밍을 기본으로 설계되었습니다. Pages Router는 이전 세대 모델로 `getServerSideProps` 같은 방식이 중심입니다. 최신 Next.js에서는 보통 App Router가 성능/구조 측면에서 더 유리한 출발점입니다.
5. **Server Action이란 무엇인가요?**  
Server Action은 폼이나 컴포넌트에서 직접 호출 가능한 "서버에서 실행되는 함수"입니다. 많은 경우 별도 API 라우트를 만들지 않고도 mutation을 처리할 수 있게 해 줍니다. 다만 입력 검증, 권한, 에러 처리는 여전히 서버에서 엄격하게 해야 합니다.
6. **데이터를 서버에서 가져올지, 클라이언트에서 가져올지 기준은 무엇인가요?**  
초기 데이터, 보안/시크릿, 번들 크기, 캐싱 이점이 중요하면 서버 페칭이 기본값입니다. 사용자 상호작용 중심이거나, 초기 렌더 이후 자주 갱신되는 데이터는 클라이언트 페칭이 적합합니다. 좋은 기본 전략은 "서버 우선, 필요할 때만 클라이언트"입니다.
7. **hydration 에러의 흔한 원인은 무엇인가요?**  
`Date.now()`, `Math.random()` 같은 비결정적 값, 렌더 중 `window` 접근, 서버/클라이언트에서 다른 조건 분기, locale/timezone 차이가 흔한 원인입니다. 대부분은 렌더를 결정적으로 만들고, 클라이언트 전용 로직을 분리하면 해결됩니다.
8. **edge runtime과 node runtime의 차이는 무엇인가요?**  
edge는 사용자에 가깝게 실행되어 지연이 낮지만, API/라이브러리 제약이 더 큽니다. node는 호환성과 생태계가 넓어서 복잡한 서버 로직에 유리합니다. 보통 "지연 민감하고 단순하면 edge, 복잡하고 의존성 많으면 node"로 설명하면 설득력이 있습니다.
9. **Next.js는 이미지 최적화를 어떻게 처리하나요?**  
`next/image`가 반응형 사이징, 지연 로딩, 포맷 최적화를 도와줍니다. 또한 크기 정보를 명시해 레이아웃 시프트를 줄이는 데 기여합니다. 특별한 이유가 없다면 기본값처럼 쓰는 편이 안전합니다.
10. **`use client`를 불필요하게 쓰면 어떤 일이 생기나요?**  
해당 모듈과 그 하위 의존성이 클라이언트 번들로 강제 포함됩니다. 결과적으로 전송되는 JS가 늘고 hydration 비용도 커질 수 있습니다. 실무에서는 `use client`를 "가장 작은 인터랙티브 리프"에 두는 습관이 성능에 유리합니다.

## 5. 렌더링 전략
1. **CSR vs SSR vs SSG vs ISR의 트레이드오프는 무엇인가요?**  
CSR은 단순하지만 초기 의미 있는 화면이 JS에 의존해 늦어지기 쉽습니다. SSR은 초기 표시/SEO에 유리하지만 서버 비용과 TTFB가 관건입니다. SSG는 런타임이 가장 빠르지만 정적이고, ISR은 정적 속도와 주기적 신선도 사이의 균형입니다.
2. **SSR이 오히려 성능에 해가 되는 경우는 언제인가요?**  
서버 작업이 무겁거나, 순차적(waterfall)이고, 캐시가 약할 때 TTFB를 크게 늘릴 수 있습니다. 클라이언트 JS가 여전히 크다면 SSR 이점이 체감으로 이어지지 않을 수도 있습니다. 그래서 SSR은 캐싱/병렬화/클라이언트 번들 축소와 함께 설계해야 효과가 큽니다.
3. **정적으로 생성하면 안 되는 페이지는 어떤 것들인가요?**  
사용자마다 결과가 달라지거나, 요청마다 달라지거나, 민감한 데이터가 포함되는 페이지입니다. 예: 인증 대시보드, 요청 헤더/세션에 의존한 개인화 화면. 이런 경우는 SSR이나 서버 컴포넌트 기반 요청 시점 데이터가 더 적합합니다.
4. **Next.js 데이터 페칭에서 캐싱은 어떻게 동작하나요?**  
App Router에서는 서버 `fetch`가 기본 캐시될 수 있고, `cache`, `revalidate`, 태그 기반 무효화 같은 옵션으로 신선도/속도를 조절합니다. 핵심은 캐시를 "기본 동작"이 아니라 "설계 대상"으로 다루는 것입니다. 어떤 데이터가 얼마나 신선해야 하는지 먼저 정의하는 편이 좋습니다.
5. **revalidation이란 무엇인가요?**  
캐시된 결과를 시간 기반 또는 온디맨드 방식으로 새로고침하는 과정입니다. 정적/캐시된 속도를 유지하면서도 데이터 신선도를 관리할 수 있습니다. ISR은 revalidation을 활용한 대표적인 패턴입니다.
6. **stale-while-revalidate는 무엇인가요?**  
일단 캐시된 결과를 즉시 보여주고, 뒤에서 새 데이터를 받아 캐시를 갱신하는 전략입니다. 사용자는 빠르게 응답을 받고, 이후 결과가 조용히 최신화됩니다. 약간의 stale을 허용할 수 있을 때 매우 강력한 기본값입니다.
7. **클라이언트 사이드 페칭이 더 나은 경우는 언제인가요?**  
사용자 상호작용 이후에만 필요한 데이터, 매우 자주 바뀌는 데이터, 라이브 업데이트가 필요한 경우입니다. 초기 렌더를 막지 않고 후속 인터랙션에 집중할 때 유리합니다. 다만 가능한 경우 "초기 값은 서버, 이후 갱신은 클라이언트" 조합이 강력합니다.
8. **streaming SSR이란 무엇인가요?**  
모든 데이터가 준비될 때까지 기다리지 않고, 준비된 부분부터 HTML을 나눠 보내는 SSR 방식입니다. Suspense 경계가 스트리밍 단위를 자연스럽게 정의합니다. 체감 속도와 진행감을 개선하는 데 효과적입니다.
9. **TTFB를 줄이는 방법은 무엇인가요?**  
독립적인 요청을 먼저 시작하고 나중에 기다리는 방식으로 waterfall을 줄이고, 병렬화를 강화합니다. 캐싱을 공격적으로 쓰고, 요청 경로에서 비핵심 작업을 제거합니다. Next.js에서는 서버 컴포넌트 + 캐시 전략 설계가 가장 큰 레버리지인 경우가 많습니다.
10. **layout shift는 왜 발생하나요?**  
초기 렌더 이후 요소의 크기/위치가 바뀔 때 발생합니다. 대표 원인은 크기 예약 없는 이미지/광고, 늦게 로드되는 폰트, 위쪽에 콘텐츠가 끼어드는 경우입니다. 해결은 공간 예약, `next/image` 활용, 늦은 DOM 변경 최소화입니다.

## 6. 성능 엔지니어링
1. **불필요한 리렌더는 어떻게 찾나요?**  
React DevTools Profiler로 어떤 컴포넌트가 왜 자주 렌더되는지부터 확인합니다. 필요하면 highlight updates나 임시 렌더 카운터를 추가합니다. 이후 state 위치 조정, 의존성 안정화, 필요한 곳에만 메모이제이션을 적용합니다.
2. **성능 측정에 어떤 도구를 쓰나요?**  
페이지 수준에서는 Lighthouse와 Web Vitals(LCP, INP, CLS)를 보고, 컴포넌트 수준에서는 React Profiler와 브라우저 Performance 패널을 봅니다. 실제 개선은 프로덕션 텔레메트리로 검증하는 것이 가장 확실합니다. 측정 없이 최적화하지 않는다는 원칙을 강조하면 좋습니다.
3. **번들 크기에 가장 큰 영향을 주는 것은 무엇인가요?**  
큰 의존성, 넓은 import(특히 barrel), 서버 전용 로직의 클라이언트 유입, 과한 client component 사용이 주요 원인입니다. 실전에서는 "서버 우선 렌더링"과 "의도적인 import"가 가장 큰 효과를 냅니다. 번들은 설계의 결과물이라는 관점이 중요합니다.
4. **브라우저로 보내는 JS를 어떻게 줄이나요?**  
가능한 서버 컴포넌트에 머물게 하고, 라우트/기능 단위로 코드 스플리팅하며, 무거운 UI는 지연 로딩합니다. import는 좁게 하고, 서버 유틸이 클라이언트로 들어오지 않게 경계를 지킵니다. 비핵심 서드파티 스크립트는 지연/조건부 로딩이 기본 전략입니다.
5. **code splitting이란 무엇인가요?**  
번들을 더 작은 청크로 나눠 "필요할 때만" 로드하는 전략입니다. 초기 로드 성능을 개선할 수 있습니다. 다만 요청 수가 늘 수 있어, 사용자 흐름을 기준으로 어디를 나눌지 결정합니다.
6. **tree shaking이란 무엇인가요?**  
빌드 시 사용하지 않는 export를 제거해 죽은 코드를 번들에서 없애는 최적화입니다. ESM과 깔끔한 import 패턴에서 가장 잘 작동합니다. 하지만 라이브러리 자체가 크면 흔들어도 큰 경우가 많다는 점을 함께 언급하면 현실적입니다.
7. **프론트엔드 메모리 누수는 왜 생기나요?**  
cleanup 없는 구독/타이머/이벤트 리스너, 언마운트 이후 state 업데이트, 장수 캐시/refs에 큰 객체를 붙잡는 패턴이 흔합니다. effect cleanup을 습관화하고, 의심될 때는 프로파일링으로 확인합니다. 누수는 "정리하지 않은 수명"의 문제로 설명하면 명확합니다.
8. **큰 리스트는 어떻게 최적화하나요?**  
가장 큰 레버는 virtualization/windowing입니다. 여기에 안정적인 key, 행(row) 컴포넌트의 적절한 메모이제이션, 렌더 경로의 비싼 계산 제거를 더합니다. 보통은 virtualization 하나로 체감 개선이 큽니다.
9. **virtualization이란 무엇인가요?**  
긴 리스트에서 보이는 구간만 렌더하고, 스크롤하면서 DOM을 재사용하는 기법입니다. 렌더 시간, DOM 크기, 메모리 사용량을 동시에 줄여 줍니다. 큰 리스트 성능 문제의 표준 해법입니다.
10. **인터랙션 지연이 느려지는 프론트엔드 원인은 무엇인가요?**  
메인 스레드의 긴 동기 작업, 큰 리렌더 파동, 레이아웃 스래싱, 과도한 클라이언트 JS가 주된 원인입니다. Performance 패널의 long task, React Profiler의 느린 커밋을 중심으로 원인을 찾습니다. 해결은 "일을 줄이거나, 미루거나, 서버로 옮기는 것"입니다.

## 7. 상태 관리
1. **React Context는 언제 문제가 되나요?**  
크거나 자주 바뀌는 값을 context로 흘리면 소비자들이 광범위하게 리렌더링될 수 있습니다. 테마/권한 메타데이터처럼 비교적 정적인 교차 관심사에는 잘 맞습니다. 자주 변하는 공유 상태는 selector가 있는 스토어/서버 상태 도구가 더 나은 경우가 많습니다.
2. **server state와 client state의 차이는 무엇인가요?**  
server state는 외부 시스템에 있고, 페칭/캐싱/무효화/동기화 문제가 핵심입니다. client state는 모달, 폼, 탭 같은 로컬 UI 상태로 즉시 갱신 가능합니다. 문제의 성격이 달라서 도구와 패턴도 다르게 가져가는 것이 안정적입니다.
3. **언제 React Query / TanStack Query를 선택하나요?**  
문제가 명확히 server state일 때 선택합니다: 캐싱, 중복 제거, 백그라운드 갱신, 재시도, 무효화 규칙이 필요할 때입니다. 커스텀 effect 코드를 크게 줄이고 데이터 흐름을 표준화할 수 있습니다. Next.js에서는 서버 초기값 + 클라이언트 갱신 조합이 특히 강력합니다.
4. **전역 상태가 불필요한 경우는 언제인가요?**  
상태가 작은 서브트리 안에서만 쓰인다면, 가장 가까운 공통 부모로 올리는 것이 더 단순하고 유지보수에 유리합니다. 전역 상태는 조정 비용과 렌더 영향 범위를 늘립니다. "정말 멀리 떨어진 여러 곳이 동시에 필요할 때"만 도입하는 편이 안전합니다.
5. **prop drilling은 어떻게 피하나요?**  
상태를 쓰는 곳 가까이에 두고, 컴포지션으로 데이터 흐름을 자연스럽게 만드는 것이 1순위입니다. 멀리 떨어진 소비자가 필요하면 context를 선택적으로 쓰거나 selector 가능한 스토어를 씁니다. children/render props로 경계를 유지하는 것도 실전에서 자주 쓰는 방법입니다.
6. **state normalization이란 무엇인가요?**  
엔티티를 ID 기준으로 저장하고, 참조로 연결하는 방식입니다. 중복을 줄이고 업데이트를 예측 가능하게 만듭니다. 여러 화면에서 같은 데이터를 참조할 때 특히 효과적입니다.
7. **큰 기능에서 상태를 어떻게 구조화하나요?**  
server state와 UI state를 분리하고, feature 경계 안에서 소유권을 명확히 합니다. 상태를 사용자 흐름과 상태 전이(status) 중심으로 모델링합니다. 데이터 페칭과 표현을 나눠두면 변경이 훨씬 안전해집니다.
8. **라우트 변경 시 상태는 어떻게 리셋하나요?**  
라우트/파라미터를 key로 삼아 컴포넌트를 재마운트시키는 방법이 간단하고 명확합니다. 또는 라우트 변화를 감지하는 effect에서 필요한 상태만 선택적으로 초기화합니다. 중요한 건 "리셋 규칙이 코드에서 분명히 보이게" 만드는 것입니다.
9. **상태가 유지보수하기 어려워지는 원인은 무엇인가요?**  
진실의 원천이 여러 개이거나, 컴포넌트 간 결합이 암묵적이거나, 도메인과 맞지 않는 상태 모양을 가질 때입니다. effect로 억지 동기화를 많이 할수록 취약해집니다. 소유권 명확화와 명시적 상태 전이가 가장 강력한 해법입니다.
10. **복잡한 UI 흐름에 도움이 되는 패턴은 무엇인가요?**  
reducer나 상태 머신으로 전이를 명시화하면 테스트와 추론이 쉬워집니다. `idle | loading | success | error` 같은 상태 열거형을 적극적으로 씁니다. 또한 "데이터 문제"와 "뷰 상태 문제"를 분리하면 복잡도가 크게 줄어듭니다.

## 8. API, 비동기 & 데이터 흐름
1. **로딩, 에러, 빈 상태는 어떻게 처리하나요?**  
처음부터 상태 모델에 명시적으로 포함시키고, 각 상태의 UI를 설계합니다. 이렇게 하면 해피패스만 있는 UI를 피할 수 있습니다. 제품 품질을 좌우하는 부분이라 초기에 합의하는 편이 좋습니다.
2. **API 호출에서 race condition은 어떻게 피하나요?**  
오래된 요청을 취소하고, 요청 ID/순서를 추적해서 최신 응답만 반영합니다. 핵심은 "더 이상 유효하지 않은 응답이 UI를 덮어쓰지 못하게" 하는 것입니다. 서버 상태 라이브러리는 이 문제를 기본적으로 잘 다룹니다.
3. **검색 요청을 debounce하려면 어떻게 하나요?**  
입력값 또는 요청 트리거를 타이머로 지연시키고 cleanup에서 타이머를 지웁니다. 쿼리 변경 시 진행 중인 요청도 취소합니다. 면접에서는 UX 개선과 API 부하 절감을 함께 언급하면 좋습니다.
4. **optimistic UI란 무엇인가요?**  
요청이 성공했다고 가정하고 UI를 먼저 업데이트한 뒤, 실패 시 롤백/보정하는 전략입니다. 체감 속도는 좋아지지만 실패 전략이 반드시 필요합니다. 성공 확률이 높고 되돌리기 쉬운 액션에 적합합니다.
5. **오래된 요청은 어떻게 취소하나요?**  
`fetch`라면 `AbortController`를 사용해 cleanup이나 최신 요청 발생 시 abort합니다. 라이브러리를 쓴다면 그 cancellation 메커니즘을 따릅니다. 취소는 성능뿐 아니라 정확성 도구이기도 합니다.
6. **실패한 요청은 어떻게 재시도하나요?**  
지수 백오프와 재시도 횟수 제한을 두고, 안전/멱등한 작업에만 재시도합니다. 에러는 사용자에게 의미 있게 보여주고, 무한 재시도 루프는 피합니다. 기본 재시도 정책을 엔드포인트 특성에 맞춰 조정합니다.
7. **느린 API는 어떻게 우아하게 처리하나요?**  
입력 반응성은 유지하고, 스켈레톤/의미 있는 fallback을 보여주며, 가능한 경우 부분 렌더/스트리밍을 사용합니다. 전체 페이지가 가장 느린 호출에 묶이지 않게 설계합니다. 핵심은 "기다림을 줄이기"보다 "기다림을 덜 느끼게 하기"입니다.
8. **중복 제출은 어떻게 막나요?**  
클라이언트에서는 pending 동안 제출을 막고, 서버에서는 멱등성/중복 방지를 강제합니다. 중요한 액션일수록 서버 보호가 필수입니다. 프런트만으로는 완전한 방어가 어렵습니다.
9. **UI 데이터가 일관되지 않게 되는 원인은 무엇인가요?**  
응답 순서 뒤바뀜, 무효화 누락, 여러 캐시의 불일치가 대표 원인입니다. 로컬 상태가 서버 진실과 어긋나는 것도 흔합니다. 무효화 규칙을 명시하고 진실의 원천을 줄이면 대부분 해결됩니다.
10. **에러 바운더리는 어떻게 설계하나요?**  
위험한 서브트리 주위에 배치해 전체 페이지가 죽지 않게 합니다. fallback은 유용해야 하고, 로깅과 복구 경로(재시도/이동)를 함께 제공해야 합니다. Next.js에서는 라우트 단위 에러 경계도 적극적으로 활용합니다.

## 9. 디버깅 & 엔지니어링 성숙도
1. **어려운 버그를 고친 사례를 말해 보세요.**  
STAR 구조로 말합니다: 증상 → 가설 → 실험 → 원인 → 해결 → 재발 방지. 면접관은 정답 자체보다도 문제 해결 과정과 리스크 관리 능력을 봅니다. 수치나 지표 개선으로 마무리하면 더 강력합니다.
2. **프로덕션에서만 발생하는 이슈는 어떻게 디버깅하나요?**  
환경 차이(빌드, 플래그, 데이터, 캐시, 타이밍)를 먼저 의심하고, 타겟 로그/텔레메트리를 심습니다. 프로덕션과 유사한 데이터로 재현을 시도하고, 최근 변경을 좁혀 갑니다. 필요하면 bisect처럼 변경 범위를 체계적으로 줄입니다.
3. **"가끔 랜덤하게 깨지는" 상황에서는 무엇부터 하나요?**  
재현을 안정화하고, 실패 조건을 좁혀 최소 재현 케이스를 만듭니다. 최근 diff, 설정 변경, 환경 요인을 빠르게 확인합니다. 가설을 하나씩 검증하는 작은 루프가 가장 빠른 길입니다.
4. **렌더링 버그는 어떻게 격리하나요?**  
입력을 고정하고 최소 재현을 만든 뒤, key/identity/의존성/상태 소유권을 순서대로 의심합니다. React DevTools로 렌더 트리를 확인하며 어디서 출력이 갈리는지 찾습니다. 렌더 버그는 대부분 "정체성"이나 "동기화" 문제로 귀결됩니다.
5. **성능 회귀는 어떻게 디버깅하나요?**  
무엇이 나빠졌는지 먼저 정의합니다(LCP, INP, TTFB, 특정 인터랙션 등). 그다음 프로파일링으로 핫패스를 찾고, 가장 작은 수정으로 병목을 제거한 뒤 다시 측정합니다. 성능 작업은 항상 측정으로 닫는 것이 핵심입니다.
6. **브라우저 도구는 무엇을 가장 많이 쓰나요?**  
Network(요청/캐시/워터폴), Performance(long task/레이아웃/페인트), Elements(CSS/DOM), React DevTools(렌더/프로파일링)를 가장 많이 씁니다. Application 탭은 스토리지/캐시 문제에서 유용합니다. 도구 선택은 증상에서 출발합니다.
7. **새로운 버그를 만들지 않으려면 어떻게 하나요?**  
PR을 작게 유지하고, 불변 조건을 코드/타입/테스트로 명시합니다. 변경 주변의 핵심 플로우와 엣지 상태를 직접 확인합니다. 작은 단위의 확실한 개선이 장기적으로 가장 빠릅니다.
8. **엣지 케이스는 어떻게 테스트하나요?**  
상태와 전이 관점으로 생각합니다: 빈 값, 에러, 느림, 부분 성공, 순서 뒤바뀜, 중복 입력, 중간 이동 등입니다. 해피패스보다 "실패/느림/경계"에서 품질이 갈립니다. 테스트 케이스는 사용자 행동 시나리오 형태가 가장 강합니다.
9. **프로덕션에 절대 남기면 안 되는 로그는 무엇인가요?**  
PII, 시크릿, 토큰, 보안에 민감한 내부 정보는 절대 금지입니다. 또한 신호 대비 소음이 큰 디버그 로그도 피해야 합니다. 프로덕션 로그는 구조화, 최소화, 개인정보 보호가 기준입니다.
10. **자기 PR은 어떻게 리뷰하나요?**  
"낯선 사람이 본다"는 전제로 실행해 보고, 명확성/리스크/의도 대비 구현을 점검합니다. 죽은 코드, 불필요한 복잡도, 경계 누수를 제거합니다. 리뷰어가 "무엇이 왜 바뀌었는지"를 빠르게 이해할 수 있게 만드는 것이 목표입니다.

## 10. 아키텍처, UX & 제품 사고
1. **큰 기능에서 컴포넌트 구조는 어떻게 잡나요?**  
feature 중심으로 구조화하고, 데이터 경계와 상태 소유권을 명확히 합니다. 인터랙션은 작은 client component로 격리하고, 가능한 한 서버 컴포넌트로 밀어 번들을 줄입니다. 경계가 명확할수록 변경이 쉬워집니다.
2. **프론트엔드 코드가 유지보수하기 어려워지는 이유는 무엇인가요?**  
숨은 결합, 불명확한 데이터 흐름, 관심사 혼합, 패턴 불일치가 대표적입니다. effect로 억지 동기화를 많이 할수록 깨지기 쉬워집니다. 유지보수성은 "명확한 경계와 예측 가능한 흐름"에서 나옵니다.
3. **재사용 가능한 컴포넌트는 어떻게 설계하나요?**  
컴포지션을 우선하고, 공개 API를 작고 명확하게 유지합니다. 두 번째 실제 사용 사례가 나오기 전에는 과한 추상화를 피합니다. 좋은 재사용은 중복을 줄이되, 범용성 때문에 오히려 복잡해지지 않아야 합니다.
4. **주니어가 자주 놓치는 UX 상태는 무엇인가요?**  
로딩, 빈 상태, 에러, 느림, 부분 데이터, 비활성 상태, 키보드/포커스 상태를 자주 놓칩니다. 이런 상태가 사용자 체감 품질을 크게 좌우합니다. UI 설계 전에 상태 목록을 먼저 쓰는 습관이 매우 효과적입니다.
5. **속도와 코드 품질은 어떻게 균형을 잡나요?**  
시간을 박스화하고, 요구사항을 만족하는 가장 단순한 해법을 선택합니다. 동시에 이후 개선이 쉬운 "깨끗한 이음새(seam)"를 남겨 둡니다. 속도와 품질은 범위 관리와 명확성으로 같이 가져갈 수 있습니다.
6. **PM에게 기술 제약을 어떻게 설명하나요?**  
기술 용어보다 사용자 영향과 트레이드오프로 번역해 말합니다. 선택지와 비용/리스크를 함께 제시합니다. "안 된다"가 아니라 "이 목표를 달성하는 현실적인 옵션들"로 프레이밍하는 것이 좋습니다.
7. **접근성 기본기는 어떻게 챙기나요?**  
시맨틱 HTML, 레이블, 키보드 내비게이션, 포커스 관리, 대비를 기본값으로 합니다. 그다음 키보드 전용 흐름과 감사 도구로 검증합니다. 접근성은 처음부터 포함할수록 비용이 낮습니다.
8. **UI가 빠르게 "느껴지게" 만드는 요소는 무엇인가요?**  
즉각적인 피드백, 안정적인 레이아웃, 점진적 표시, 입력 반응성 유지가 핵심입니다. 스켈레톤, 스트리밍, 낙관적 업데이트가 체감 속도에 큰 영향을 줍니다. 절대 시간보다 "진행감"이 더 중요할 때가 많습니다.
9. **오버엔지니어링은 어떻게 막나요?**  
사용자 문제를 기준으로 결정하고, 단순한 해법을 우선합니다. 실제 두 번째 사용 사례가 나오기 전에는 일반화를 미룹니다. 복잡도는 가치에 비례해야 한다는 원칙을 지킵니다.
10. **AI 시대에 프론트엔드는 어떻게 계속 성장하나요?**  
AI로 탐색 속도를 높이되, 공식 문서와 측정으로 검증합니다. 렌더링, 네트워킹, 성능, 디버깅 같은 기반기를 더 단단히 합니다. 결국 실전 프로젝트와 회고가 가장 빠른 성장 루프입니다.
